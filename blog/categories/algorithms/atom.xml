<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[catogories：Algorithms | Steven's Blog]]></title>
  <link href="http://isunix.github.io/blog/categories/algorithms/atom.xml" rel="self"/>
  <link href="http://isunix.github.io/"/>
  <updated>2024-09-05T21:40:43+08:00</updated>
  <id>http://isunix.github.io/</id>
  <author>
    <name><![CDATA[Steven Sun]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Python倒置一个链表]]></title>
    <link href="http://isunix.github.io/blog/2015/09/15/reverse-a-linked-list-in-place/"/>
    <updated>2015-09-15T09:33:40+08:00</updated>
    <id>http://isunix.github.io/blog/2015/09/15/reverse-a-linked-list-in-place</id>
    <content type="html"><![CDATA[<p>We will show how to reverse a linked list in place using both python and javascript(actually converted from coffeescript).</p>

<p>1.python version:</p>

<p>```py
class ListNode:
    def <strong>init</strong>(self, x):
        self.val = x
        self.next = None</p>

<p>def reverse(head):
    p = head
    start = None
    while p:
        next_one = p.next
        p.next = start
        start = p
        p = next_one</p>

<pre><code>return start
</code></pre>

<p>head = ListNode(1)
head.next = ListNode(2)
head.next.next = ListNode(3)</p>

<p>result = reverse(head)
while result:
    print result.val
    result = result.next
```</p>

<p>2.javascript version:</p>

<p>```js
// Generated by CoffeeScript 1.9.3
var ListNode, head, result, reverse_linkedList;</p>

<p>ListNode = (function() {
  function ListNode(val) {
    this.val = val;
    this.next = null;
  }</p>

<p>return ListNode;</p>

<p>})();</p>

<p>reverse_linkedList = function(head) {
  var next_one, p, start;
  p = head;
  start = null;
  while (p) {
    next_one = p.next;
    p.next = start;
    start = p;
    p = next_one;
  }
  return start;
};</p>

<p>head = new ListNode(1);</p>

<p>head.next = new ListNode(2);</p>

<p>head.next.next = new ListNode(3);</p>

<p>result = reverse_linkedList(head);</p>

<p>while (result) {
  console.log(result.val);
  result = result.next;
}
```</p>

<p>3.to reverse a linked from position m to n:</p>

<p>```py
class ListNode(object):
    def <strong>init</strong>(self, x):
        self.val = x
        self.next = None</p>

<p>class Solution(object):
    def reverseBetween(self, head, m, n):
        dummyNode = ListNode(0)
        p = dummyNode
        q = head</p>

<pre><code>    for x in range(m-1):
        p.next = q
        q = q.next
        p = p.next

    start = None
    end = q
    next_one = None

    for x in range(m, n+1):
        next_one = q.next
        q.next = start
        start = q
        q = next_one


    p.next = start
    end.next = next_one
    return dummyNode.next
</code></pre>

<p>if <strong>name</strong> == ‘<strong>main</strong>’:
    solution = Solution()</p>

<pre><code>head = ListNode(1)
head.next = ListNode(2)
head.next.next = ListNode(3)
head.next.next.next = ListNode(4)
head.next.next.next.next = ListNode(5)

m, n = 2, 4

result = solution.reverseBetween(head, m, n)
while result:
    print result.val
    result = result.next ```
</code></pre>

<p>4.we will also show another ways to reverse a linked list, first the cursive way:</p>

<p>```py
class ListNode:
    def <strong>init</strong>(self, x):
        self.val = x
        self.next = None</p>

<p>def reverse(head):
    if head == None or head.next == None:
        return head</p>

<pre><code>second = head.next
head.next = None
result = reverse(second)
second.next = head

return result
</code></pre>

<p>head = ListNode(1)
head.next = ListNode(2)
head.next.next = ListNode(3)</p>

<p>result = reverse(head)
while result:
    print result.val
    result = result.next
```</p>

<p>```js
// Generated by CoffeeScript 1.9.3
var ListNode, head, result, reverse_linkedList;</p>

<p>ListNode = (function() {
  function ListNode(val) {
    this.val = val;
    this.next = null;
  }</p>

<p>return ListNode;</p>

<p>})();</p>

<p>reverse_linkedList = function(head) {
  var result, second;
  if (head === null || head.next === null) {
    return head;
  }
  second = head.next;
  head.next = null;
  result = reverse_linkedList(second);
  second.next = head;
  return result;
};</p>

<p>head = new ListNode(1);</p>

<p>head.next = new ListNode(2);</p>

<p>head.next.next = new ListNode(3);</p>

<p>result = reverse_linkedList(head);</p>

<p>while (result) {
  console.log(result.val);
  result = result.next;
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[顺序栈和链栈的c语言实现]]></title>
    <link href="http://isunix.github.io/blog/2014/08/19/shun-xu-zhan-de-cyu-yan-shi-xian/"/>
    <updated>2014-08-19T21:29:35+08:00</updated>
    <id>http://isunix.github.io/blog/2014/08/19/shun-xu-zhan-de-cyu-yan-shi-xian</id>
    <content type="html"><![CDATA[<p>1.sequence stack </p>

<p>```c
#include “stdio.h”
#include “stdlib.h”
#include “math.h”
#include “time.h”</p>

<h1 id="define-ok-1">define OK 1</h1>
<p>#define ERROR 0
#define TRUE 1
#define FALSE 0
#define MAXSIZE 1000 /* 存储空间初始分配量 */</p>

<p>typedef int Status;
typedef int SElemType; /* SElemType类型根据实际情况而定，这里假设为int */</p>

<p>/* 顺序栈结构 <em>/
typedef struct
{
        SElemType data[MAXSIZE];
        int top; /</em> 用于栈顶指针 */
}SqStack;</p>

<p>Status visit(SElemType c)
{
        printf(“%d “,c);
        return OK;
}</p>

<p>/*  构造一个空栈S <em>/
Status InitStack(SqStack *S)
{
        /</em> S.data=(SElemType <em>)malloc(MAXSIZE</em>sizeof(SElemType)); */
        S-&gt;top=-1;
        return OK;
}</p>

<p>/* 把S置为空栈 */
Status ClearStack(SqStack *S)
{
        S-&gt;top=-1;
        return OK;
}</p>

<p>/* 若栈S为空栈，则返回TRUE，否则返回FALSE */
Status StackEmpty(SqStack S)
{
        if (S.top==-1)
                return TRUE;
        else
                return FALSE;
}</p>

<p>/* 返回S的元素个数，即栈的长度 */
int StackLength(SqStack S)
{
        return S.top+1;
}</p>

<p>/* 若栈不空，则用e返回S的栈顶元素，并返回OK；否则返回ERROR */
Status GetTop(SqStack S,SElemType *e)
{
        if (S.top==-1)
                return ERROR;
        else
                *e=S.data[S.top];
        return OK;
}</p>

<p>/* 插入元素e为新的栈顶元素 <em>/
Status Push(SqStack *S,SElemType e)
{
        if(S-&gt;top == MAXSIZE -1) /</em> 栈满 <em>/
        {
                return ERROR;
        }
        S-&gt;top++;				/</em> 栈顶指针增加一 <em>/
        S-&gt;data[S-&gt;top]=e;  /</em> 将新插入元素赋值给栈顶空间 */
        return OK;
}</p>

<p>/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR <em>/
Status Pop(SqStack *S,SElemType *e)
{
        if(S-&gt;top==-1)
                return ERROR;
        *e=S-&gt;data[S-&gt;top];	/</em> 将要删除的栈顶元素赋值给e <em>/
        S-&gt;top–;				/</em> 栈顶指针减一 */
        return OK;
}</p>

<p>/* 从栈底到栈顶依次对栈中每个元素显示 */
Status StackTraverse(SqStack S)
{
        int i;
        i=0;
        while(i&lt;=S.top)
        {
                visit(S.data[i++]);
        }
        printf(“\n”);
        return OK;
}</p>

<p>int main()
{
        int j;
        SqStack s;
        int e;
        if(InitStack(&amp;s)==OK)
                for(j=1;j&lt;=10;j++)
                        Push(&amp;s,j);
        printf(“栈中元素依次为：”);
        StackTraverse(s);
        Pop(&amp;s,&amp;e);
        printf(“弹出的栈顶元素 e=%d\n”,e);
        printf(“栈空否：%d(1:空 0:否)\n”,StackEmpty(s));
        GetTop(s,&amp;e);
        printf(“栈顶元素 e=%d 栈的长度为%d\n”,e,StackLength(s));
        ClearStack(&amp;s);
        printf(“清空栈后，栈空否：%d(1:空 0:否)\n”,StackEmpty(s));</p>

<pre><code>    return 0; } ```  
</code></pre>

<p>2.Linked stack</p>

<p>```c
#include “stdio.h”
#include “stdlib.h”
#include “math.h”
#include “time.h”</p>

<h1 id="define-ok-1-1">define OK 1</h1>
<p>#define ERROR 0
#define TRUE 1
#define FALSE 0
#define MAXSIZE 1000 /* 存储空间初始分配量 */</p>

<p>typedef int Status;
typedef int SElemType; /* SElemType类型根据实际情况而定，这里假设为int */</p>

<p>/* 链栈结构 <em>/
typedef struct StackNode
{
        SElemType data;
        struct StackNode *next;
}StackNode,</em>LinkStackPtr;</p>

<p>typedef struct
{
        LinkStackPtr top;
        int count;
}LinkStack;</p>

<p>Status visit(SElemType c)
{
        printf(“%d “,c);
        return OK;
}</p>

<p>/*  构造一个空栈S */
Status InitStack(LinkStack *S)
{
        S-&gt;top = (LinkStackPtr)malloc(sizeof(StackNode));
        if(!S-&gt;top)
                return ERROR;
        S-&gt;top=NULL;
        S-&gt;count=0;
        return OK;
}</p>

<p>/* 把S置为空栈 */
Status ClearStack(LinkStack *S)
{
        LinkStackPtr p,q;
        p=S-&gt;top;
        while(p)
        {
                q=p;
                p=p-&gt;next;
                free(q);
        }
        S-&gt;count=0;
        return OK;
}</p>

<p>/* 若栈S为空栈，则返回TRUE，否则返回FALSE */
Status StackEmpty(LinkStack S)
{
        if (S.count==0)
                return TRUE;
        else
                return FALSE;
}</p>

<p>/* 返回S的元素个数，即栈的长度 */
int StackLength(LinkStack S)
{
        return S.count;
}</p>

<p>/* 若栈不空，则用e返回S的栈顶元素，并返回OK；否则返回ERROR */
Status GetTop(LinkStack S,SElemType *e)
{
        if (S.top==NULL)
                return ERROR;
        else
                *e=S.top-&gt;data;
        return OK;
}</p>

<p>/* 插入元素e为新的栈顶元素 <em>/
Status Push(LinkStack *S,SElemType e)
{
        LinkStackPtr s=(LinkStackPtr)malloc(sizeof(StackNode));
        s-&gt;data=e;
        s-&gt;next=S-&gt;top;	/</em> 把当前的栈顶元素赋值给新结点的直接后继 <em>/
        S-&gt;top=s;         /</em> 将新的结点s赋值给栈顶指针 */
        S-&gt;count++;
        return OK;
}</p>

<p>/* 若栈不空，则删除S的栈顶元素，用e返回其值，并返回OK；否则返回ERROR <em>/
Status Pop(LinkStack *S,SElemType *e)
{
        LinkStackPtr p;
        if(StackEmpty(</em>S))
                return ERROR;
        <em>e=S-&gt;top-&gt;data;
        p=S-&gt;top;					/</em> 将栈顶结点赋值给p <em>/
        S-&gt;top=S-&gt;top-&gt;next;    /</em> 使得栈顶指针下移一位，指向后一结点 <em>/
        free(p);                    /</em> 释放结点p */
        S-&gt;count–;
        return OK;
}</p>

<p>Status StackTraverse(LinkStack S)
{
        LinkStackPtr p;
        p=S.top;
        while(p)
        {
                 visit(p-&gt;data);
                 p=p-&gt;next;
        }
        printf(“\n”);
        return OK;
}</p>

<p>int main()
{
        int j;
        LinkStack s;
        int e;
        if(InitStack(&amp;s)==OK)
                for(j=1;j&lt;=10;j++)
                        Push(&amp;s,j);
        printf(“栈中元素依次为：”);
        StackTraverse(s);
        Pop(&amp;s,&amp;e);
        printf(“弹出的栈顶元素 e=%d\n”,e);
        printf(“栈空否：%d(1:空 0:否)\n”,StackEmpty(s));
        GetTop(s,&amp;e);
        printf(“栈顶元素 e=%d 栈的长度为%d\n”,e,StackLength(s));
        ClearStack(&amp;s);
        printf(“清空栈后，栈空否：%d(1:空 0:否)\n”,StackEmpty(s));
        return 0;
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[从没有排序的链表中删除重复值]]></title>
    <link href="http://isunix.github.io/blog/2014/08/18/remove-duplicates-from-an-unsorted-linked-list/"/>
    <updated>2014-08-18T15:12:52+08:00</updated>
    <id>http://isunix.github.io/blog/2014/08/18/remove-duplicates-from-an-unsorted-linked-list</id>
    <content type="html"><![CDATA[<p>Write code to remove duplicates from an unsorted linked list.</p>

<p>FOLLOW UP</p>

<p>How would you solve this problem if a temporary buffer is not allowed?  </p>

<p>```cpp
#include <iostream>
#include <cstring>
using namespace std;</cstring></iostream></p>

<p>typedef struct node{
    int data;
    node *next;
}node;
bool myhash[100];</p>

<p>node* init(int a[], int n){
    node *head, *p;
    for(int i=0; i&lt;n; ++i){
        node *nd = new node();
        nd-&gt;data = a[i];
        if(i==0){
            head = p = nd;
            continue;
        }
        p-&gt;next = nd;
        p = nd;
    }
    return head;
}
void removedulicate(node *head){
    if(head==NULL) return;
    node *p=head, *q=head-&gt;next;
    myhash[head-&gt;data] = true;
    while(q){
        if(myhash[q-&gt;data]){
            node *t = q;
            p-&gt;next = q-&gt;next;
            q = p-&gt;next;
            delete t;
        }
        else{
            myhash[q-&gt;data] = true;
            p = q; q = q-&gt;next;
        }
    }
}
void removedulicate1(node *head){
    if(head==NULL) return;
    node *p, *q, *c=head;
    while(c){
        p=c; q=c-&gt;next;
        int d = c-&gt;data;
        while(q){
            if(q-&gt;data==d){
                node *t = q;
                p-&gt;next = q-&gt;next;
                q = p-&gt;next;
                delete t;
            }
            else{
                p = q; q = q-&gt;next;
            }
        }
        c = c-&gt;next;
    }
}
void print(node *head){
    while(head){
        cout«head-&gt;data«” ”;
        head = head-&gt;next;
    }
    cout«endl;
}
int main(){
    int n = 10;
    int a[] = {
        3, 2, 1, 3, 5, 6, 2, 6, 3, 1
    };
    memset(myhash, false, sizeof(myhash));
    node *head = init(a, n);
    removedulicate1(head);
    print(head);
    return 0;
}
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Python来实现一个栈(stack)]]></title>
    <link href="http://isunix.github.io/blog/2014/08/14/using-python-to-implement-a-stack/"/>
    <updated>2014-08-14T10:53:40+08:00</updated>
    <id>http://isunix.github.io/blog/2014/08/14/using-python-to-implement-a-stack</id>
    <content type="html"><![CDATA[<p>In this post, we are going to implement a stack using Python. We are gonna do it using two ways. The first is by pushing to the end of the list, and pop out the rightmost item. The second is by “pushing” to the leftmost and pop out the leftmost item.  </p>

<ol>
  <li>push to the end  </li>
</ol>

<p>```py
class Stack:
    def <strong>init</strong>(self):
        self.items = []</p>

<pre><code>def is_empty(self):
    return self.items == []

def push(self, item):
    self.items.append(item)

def pop(self):
    return self.items.pop()

'''
returns the top item from the stack but does not remove it.
It needs no parameters.
The stack is not modified.
'''
def peek(self):
    return self.items[len(self.items) - 1]

def size(self):
    return len(self.items)
</code></pre>

<p>s = Stack()
print (s.is_empty())
s.push(4)
s.push(‘dog’)
print (s.peek())
print(“\n”)
print (s.peek())
s.push(True)
print (s.size())
print (s.is_empty())
s.push(8.4)
print (s.pop())
print (s.pop())
print (s.size())
```  </p>

<ol>
  <li>push to the front end</li>
</ol>

<p>```py
class Stack:
    def <strong>init</strong>(self):
        self.items = []</p>

<pre><code>def is_empty(self):
    return self.items == []

#push, inserting at the front end.
def push(self, item):
    self.items.insert(0, item)

#pop out the leftest item.
def pop(self):
    return self.items.pop(0)

def peek(self):
    return self.items[0]

def size(self):
    return len(self.items)
</code></pre>

<p>s = Stack()
s.push(‘hello’)
s.push(‘true’)
print(s.pop())
print (s.pop())
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[使用Java来练习算法]]></title>
    <link href="http://isunix.github.io/blog/2014/08/14/common-tips-using-java-to-practice-algorithms/"/>
    <updated>2014-08-14T10:07:16+08:00</updated>
    <id>http://isunix.github.io/blog/2014/08/14/common-tips-using-java-to-practice-algorithms</id>
    <content type="html"><![CDATA[<p>There are common structues and tips while practicing algorithms and data structueres using java. I will try to keep them down in this post.   </p>

<p>1.hash tables  </p>

<p><code>java
public HashMap&lt;Integer, Student&gt; buildMap(Student[] students) {
  HashMap&lt;IntegerJ Student&gt; map = new HashMap&lt;Integer, Student&gt;();
    for (Student s : students) map.put(s.getld(), s);
    return map;
}
</code> </p>

<p>2.ArrayList(Dinamically Resizing Array) </p>

<p><code>java
public ArrayList&lt;String&gt; merge(String[] words, String[] more) {
  ArrayList&lt;String&gt; sentence = new Arrayl_ist&lt;String&gt;();
  for (String w : words) sentence.add(w);
  for (String w : more) sentence.add(w);
  return sentence;
}
</code>   </p>

<p>3.StringBuffer   </p>

<p><code>java
public String joinWords(String[] words){
  StringBuffer sentence = new StringBuffer();
  for (String w : words){
    sentence.append(w);
  }
  return sentence.toString();
}
</code>  </p>

<p>4.LinkedList  </p>

<p>```java<br />
class Node {
  Node next = null;
  int data;</p>

<p>public Node(int d) {
  data = d;
  }</p>

<p>void appendToTail(int d) {
    Node end = new Node(d);
    Node n = this;
    while (n.next != null) {
      n = n.next;
    }
    n.next = end;
  }
}
```  </p>

<p>5.Deleting a node from a singly linkes list.  </p>

<p>```java
Node deleteNode(Node head, int d) {
  Node n = head;</p>

<p>if (n.data == d) {
    return head.next; /* moved head */
  }</p>

<p>while (n.next 1= null) {
    if (n.next.data == d) {
      n.next = n.next.next;
      return head; /* head didn’t change */
    }
    n = n.next;
  }
  return head;
}
```  </p>

<p>6.Implementing a stack</p>

<p>```java
class Stack {
  Node top;</p>

<p>Object pop() {
    if(top != null) {
      Object item = top.data;
      p = top.next;
      return item;
    }
    return null;
  }</p>

<p>void push(0bject item) {
    Node t = new Node(item);
    next = top;
    top = t;
  }</p>

<p>Object peek() {
    return top.data;
  }
}
```  </p>

<p>7.Implementing a queue.  </p>

<p>```java<br />
class Queue {
  Node first, last;</p>

<p>void enqueue(0bject item) {
    if(first == null) {
      last = new Node(item);
      first = last;
      } else {
        last.next = new Node(item);
        last = last.next;
      }
  }</p>

<p>Object dequeueQ {
    if (first != null) {
      Object item = first.data;
      first = first.next;
      return item;
    }
    return null;
  }
}
```</p>

<p>8.pseudocode to implement DFS</p>

<p><code>java
void search(Node root) {
  if (root == null) return;
  visit(root);
  root.visited = true;
  foreach (Node n in root.adjacent) {
    if (n.visited == false) {
      search(n);
    }
  }
}
</code>  </p>

<p>9.BFS.</p>

<p>```java
void search(Node root) {
  Queue queue = new QueueQ;
  root.visited = true;
  visit(root);
  queue.enqueue(root); // Add to end of queue</p>

<p>while (!queue.isEmpty()) {
    Node r = queue.dequeueQ; // Remove from front of queue
    foreach (Node n in r.adjacent) {
      if (n.visited == false) {
        visit(n);
        n.visited = true;
        queue.enqueue(n);
      }
    }
  }
}
```</p>
]]></content>
  </entry>
  
</feed>
